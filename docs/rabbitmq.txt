1С внешняя компонента для RabbitMQ
8 июня 2024
362
5 мин
Оглавление
Демонстрация работы
Отправка сообщения в очередь
Получение сообщений
Показать ещё
В этой статье я расскажу про внешнюю компоненту для взаимодействия 1С с брокером сообщений RabbitMQ. Компонента написана с применением технологии NativeAPI , поэтому она будет работать на Windows и Linux.

Компонента разработана на двух языках. Основная логика написано на языке Rust и язык С++ используется для взаимодействия кода на Rust с платформой. За счет того что на Rust написано большая часть кода, значительно снижается риск утечки памяти и прочие проблемы присущие приложениям на С++. Так же разработка на Rust снижает время разработки/доработки/исправление ошибок.

Перед переходом к примерам, замечу что взаимодействовать из 1С с RabbitMQ можно не только с применением внешний компонент. Так же можно использовать внешний сервисы (например использовать rest proxy), которые будут выполнять роль посредника. 1С будет общаться с ним по протоколу http. Но такой подход усложняет архитектуру и создает дополнительные точки отказа. Использование же компоненты, напротив, упрощает процесс взаимодействия.

Демонстрация работы
Теперь перейду к демонстрации и примерам.

Если необходимо развернуть тестовый сервер RabbitMQ, то это делается просто, через Docker контейнер одной командой.

sudo docker run -d --rm -p 5672:5672 -p 15672:15672 rabbitmq:3-management

Эта команда запустит Docker контейнер, пробросит порты для подключения к RMQ серверу (5672) и для web администрирования (15672). Параметр --rm указывает, что контейнер надо удалить после закрытия (это удобно для тестовых целей). Параметр -d означает отключить от контейнера, т. е. Контейнер будет работать в фоне.

После запуска можно перейти в web интерфейс для администрирования.

http://127.0.0.1:15672/

Логин и пароль по умолчанию guest guest.

После запуска сервера, можно перейти к настройке и использованию самой компоненты. Компоненту можно скачать по ссылке

Так же имеется видео обзор с демонстрацией и примерами и быстрый старт.

Компонента поставляется в двух формах, в платной и бесплатной. У бесплатной версии есть одно ограничение, на размер сообщения - 10000 символов. Компонента поставляется в виде конфигурации с примерами и обработкой КлиентRMQ, которая является оберткой над компонентой, для более удобной работы с ее методами из кода. Для использования необходимо скопировать обработку КлиентRMQ в конфигурацию, вся работа реализуется через эту обработку.

Отправка сообщения в очередь
В первом примере рассмотрю отправку сообщения в очередь. Для этого создам через web интерфейс новую очередь

Добавление новой очереди в web интерфейсе
Так же необходимо привязать очередь к точке обмена и указать ключ маршрутизации, согласно которому сообщения будут попадать в эту очередь. Для этого необходимо кликнуть по созданной очереди и в разделе "привязки" (bindings) указать

Привязка очереди к точке обмена и указания ключа маршрутизации
Теперь все готово для отправки сообщения. Отправка реализуется через код ниже.

Пример отправки сообщения
В первой строке создается экземпляр обработки, через которую реализовано взаимодействие с компонентой.

Во второй, выполняется подключение к серверу. Метод возвращает объект "Подключение" который далее будет передаваться в метод для создания канала и в метод для отключения от сервера.

В третьей строке создается канал в рамках установленного соединения.

В четверной строке непосредственно отправляется сообщение в очередь. Метод ОпубликоватьСообщение возвращает результат отправки (переменная ответ)

Ответ сервера после публикации
Если сервер успешно принял сообщение, он ответит сообщением как на скриншоте выше. Чтобы сервер отвечал на публикации, нужно в методе СоздатьКанал() указать во втором параметре Истина

Установка режима отвечать на публикации сообщения со стороны сервера
Так же, обязательно, после завершения работы с подключением, не забывать его закрывать (пятая строка). Это очень важно, иначе будет происходить лишний расход памяти, особенно критично, если отправка реализована в цикле.

После отправки, можно посмотреть на опубликованное сообщение в web интерфейсе администратора.

Просмотр полученного сообщения
Получение сообщений
После отправки можно получить это сообщение.

Пример получения сообщения
В первой строке так же создается экземпляр обработки-клиента.

Во второй строке устанавливается соединение.

В третьей строке создается канал в рамках созданного выше соединения.

В четверной строке создается получатель, это сущность-поток, через которую непосредственно реализовано получение сообщений из очереди.

В пятой строке начинается цикл ожидания сообщений из очереди. Метод СледующееСообщений() это блокирующий вызов. Он блокирует поток выполнения 1С, до момента когда в очереди появится сообщение.

После того как сообщение появилось, выполнение переходит к строке номер шесть внутри цикла. Метод ДанныеСообщения() уже непосредственно возвращает само сообщение (рис. ниже).

В строке семь подтверждается полученное сообщение. После подтверждения, сервер больше не будет присылать текущее сообщение.

В строке восемь, аналогично отправке, отключение от сервера. Это так же надо делать обязательно, чтобы избежать расхода памяти. Подключение это дорого как по времени как и по памяти (это тяжелое tcp соединение). Надо избегать лишнее создание соединений и тем более не забывать их закрывать. В рамках одного соединения можно создать несколько каналов (строка три). Если это позволяет архитектура решения, можно использовать одно соединение (переменная которую возвращается в строке два) и уже в рамках этого подключения создавать несколько каналов. Каналы - это виртуальные и дешевые соединения в рамках одного физического соединения.

Получение одного сообщения
Если необходимо получить одно сообщение, не ожидая сообщения в очереди, можно использовать метод ОдноСледующееСообщение()

Пример полчения одного сообщения, без блокировки потока
В строке один вызывается метод получения сообщения, но он не блокирует поток 1С, а сразу возвращает результат, даже если сообщения в очереди не было. В строке номер два, получается само сообщение (если оно было в очереди) если его не было, в структуре сообщения в теге сообщения будет значение -1.

Пример результата при получении одного сообщения, если в очереди не было сообщений
Если же сообщение было, то в теге будет тег сообщения. Тег сообщения используется для подтверждения получения сообщения, если это необходимо.

Подтверждение получения сообщений
Обработка ошибок
Каждый метод обработки КлиентRMQ возвращает в качестве результата соответствующую структуру. Например получение сообщений вернет структуру типа Message.

Если же происходит ошибка, при вызове любого метода, то он вернет структуру с типом Error и описанием ошибки. Обработка ошибок реализуется не через оборачивание кода в попытку, а через контроль типа возвращаемого результата. Подход похож на такие языки как GO и Rust, где не используются такие конструкции языка как попытки и исключения.

Получение сообщений в фоне
В реальных сценариях удобно использовать получение сообщений в фоновом задании. Можно использовать несколько фоновых заданий для получения сообщений параллельно, для повышения скорости получения.

Больше примеров
Больше примеров можно посмотреть в конфигурации-примере, по ссылке.

Или в быстром старте.

Приобретение полной версии
По вопросам приобретения полное версии, если не хватает возможностей бесплатной, можно написать в телеграм автору.

Контанты
Телеграм автора.

Телеграм канал с прочими видео автора.

Телеграм канал с информацией о новых версиях внешних компонент автора.