
Перем ЭкземплярКомпоненты Экспорт;

Перем ТекущееСообщение Экспорт; 

Перем ЭтоLinux;                  

Перем ЗаписьЛога;

#Область Подключения
Функция ПодключитьсяКСерверу(СтрокаПодключения) Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;	
	
	РезультатПроверкиИмениИТокена = ПроверитьИмяИТокенДляКомпоненты("free", "f5df8748c434673b1faed7f316ae4d15:a31e1a7ea6de595238e8f15a4118f42a"); 
	
	Если РезультатПроверкиИмениИТокена <> "ok" Тогда
		Возврат СтруктураСОшибкой(РезультатПроверкиИмениИТокена);
	КонецЕсли;
	
	Лог("ЭкземплярКомпоненты.Подключиться Начало");
	
	Подключение = ЭкземплярКомпоненты.Подключиться(СтрокаПодключения);
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.Подключиться Конец Подключение = %1", Подключение));
	
	Возврат Десериализовать(Подключение);
КонецФункции

Функция ПодключитьКомпоненту() Экспорт
	
	Лог("ПодключитьКомпоненту");
	
	РезультатПроверки = ПроверитьВерсиюПлатформы();
	Если ЭтоОшибка(РезультатПроверки) Тогда
		ВызватьИсключение РезультатПроверки.Текст; // критичная ошибка, продолжать нельзя	
	КонецЕсли;
	
	СисИнфор = Новый СистемнаяИнформация;
	Если НЕ (СисИнфор.ТипПлатформы = ТипПлатформы.Windows_x86_64 ИЛИ СисИнфор.ТипПлатформы = ТипПлатформы.Linux_x86_64) Тогда
		СтруктураСОшибкой = СтруктураСОшибкой("Возможно подключить только на windows или linux и ТОЛЬКО на х64!");
		Лог("ПодключитьКомпоненту " + Сериализовать(СтруктураСОшибкой));
		Возврат СтруктураСОшибкой;
	КонецЕсли;
	
	ОС = "windows";
	Если СисИнфор.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		ОС = "linux";                                           
	КонецЕсли;
	
	ЭтоLinux = ОС = "linux";
	ЭтоWindows = ОС = "windows";
	
	Лог(СтрШаблон("ПодключитьКомпоненту ОС = %1", ОС));
	
	Лог("ПодключитьКомпоненту. ПодключитьВнешнююКомпоненту Начало");
	
	РезультатПодключения = ПодключитьВнешнююКомпоненту("Обработка.КлиентRMQ.Макет."+ОС, "Клиент", ТипВнешнейКомпоненты.Native); 
	
	Лог(СтрШаблон("ПодключитьКомпоненту. ПодключитьВнешнююКомпоненту Конец. Результат = %1", РезультатПодключения));
	
	Если НЕ РезультатПодключения Тогда
		ДопКомментарий = "";
		Если ЭтоWindows Тогда
			ДопКомментарий = ". Возможно не установлено ""Microsoft Visual C++ Redistributable""";
		КонецЕсли;
		ДопКомментарий = ДопКомментарий + ". Доп. информация о причинах и решениях в справке обработки КлиентRMQ.";
		СтруктураСОшибкой = СтруктураСОшибкой(СтрШаблон("Ошибка подключения внешней компоненты %1", ДопКомментарий));
		Лог(СтрШаблон("ПодключитьКомпоненту Ошибка = %1", Сериализовать(СтруктураСОшибкой)));
		Возврат СтруктураСОшибкой;
	КонецЕсли;
	
	ЭкземплярКомпоненты = Новый("AddIn.Клиент.RMQ");
	
	// установить режим работы, файловый/серверный           
	// для файлового варианты при завершении работы компоненты (метод Done) будет завершаться асинхронных рантайм rust, иначе будет аварианое завершение.
	// для серверного этого делать нельзя, так как нужно использовать общие подключения (чтобы мониторить и завершать подключения из другой подключенной компоненты)
	ЭтоФайловыйВариант = СтрНачинаетсяС(НРег(СтрокаСоединенияИнформационнойБазы()), "file");
	ЭкземплярКомпоненты.SetMode(?(ЭтоФайловыйВариант, 0, 1));
	
	Лог(СтрШаблон("ПодключитьКомпоненту ЭтоФайловыйВариант = %1(Mode:%2)", ЭтоФайловыйВариант, ЭкземплярКомпоненты.GetMode()));
	
	Лог("ПодключитьКомпоненту Успешное подключение");
	
	Возврат Истина;
	
КонецФункции

Функция ЗакрытьВсеПодключения() Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЭкземплярКомпоненты.ЗакрытьВсеПодключения();
	
КонецФункции

Функция ВалидацияСтруктурыПодключения(Подключение)
	Если НЕ (ТипЗнч(Подключение) = Тип("Структура") И Подключение.Свойство("Тип") И Подключение.Тип = "Connect") Тогда
		Возврат СтруктураСОшибкой("Не верный тип 'Подключение'");	
	КонецЕсли;	
КонецФункции

Функция ОтключитьсяОтСервера(Подключение) Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Лог("ОтключитьсяОтСервера");
	
	Результат = ВалидацияСтруктурыПодключения(Подключение);		
	Если ЭтоОшибка(Результат) Тогда
		
		Лог(СтрШаблон("ОтключитьсяОтСервера ВалидацияСтруктурыПодключения Ошибка = %1", Сериализовать(Результат)));
		
		Возврат Результат;	
	КонецЕсли;
	
	Лог("ЭкземплярКомпоненты.Отключиться Начало");
	
	Результат = ЭкземплярКомпоненты.Отключиться(Сериализовать(Подключение));
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.Отключиться Конец Результат = %1", Результат));
	
	Возврат Результат;
	
КонецФункции
#КонецОбласти

#Область Каналы
// Функция - Опции канала
//
// Параметры:
//  Подключение											 - Структура с данными подключения. Структуру возвращает метод ПодключитьсяКСерверу
//  ПодтверждениеПубликацийОтСервера					 - confirm_publication, включает режим подтверждения публикаций для канала. В этом режиме RabbitMQ подтверждает успешную доставку сообщений в очередь, иначе публикация считается неудачной. 
//  КоличествоПредзагруженныхНеПодтвержденныхСообщений	 - В RMQ свойство Qos, (Quality of Service) ограничивает количество неподтвержденных сообщений, которые потребитель может получать одновременно. Если лимит достигнут, RabbitMQ остановит отправку новых сообщений до подтверждения (ack) хотя бы одного из уже полученных. Значение этого поля критично если нужно работать с очередями типа Stream, без этого параметра будет ошибка подключения.
// 
// Возвращаемое значение:
//   - 
//
Функция ОпцииКанала(Подключение, ПодтверждатьПолучениеОтСервера = Ложь, КоличествоПредзагруженныхНеПодтвержденныхСообщений = 0)
	Результат = ВалидацияСтруктурыПодключения(Подключение);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	Возврат Новый Структура("Подключение,ПодтверждатьПолучениеОтСервера,КоличествоПредзагруженныхНеПодтвержденныхСообщений", Подключение, ПодтверждатьПолучениеОтСервера,КоличествоПредзагруженныхНеПодтвержденныхСообщений);
КонецФункции

Функция ВалидацияСтруктурыКанал(Канал)
	Если НЕ (ТипЗнч(Канал) = Тип("Структура") И Канал.Свойство("Тип") И Канал.Тип = "Channel") Тогда
		Возврат СтруктураСОшибкой("Не верный тип 'Канал'");	
	КонецЕсли;
КонецФункции

// Функция - Создать канал
//
// Параметры:
//  Подключение											 - Структура с данными подключения. Структуру возвращает метод ПодключитьсяКСерверу
//  ПодтверждениеПубликацийОтСервера					 - confirm_publication, включает режим подтверждения публикаций для канала. В этом режиме RabbitMQ подтверждает успешную доставку сообщений в очередь, иначе публикация считается неудачной. 
//  КоличествоПредзагруженныхНеПодтвержденныхСообщений	 - В RMQ свойство Qos, (Quality of Service) ограничивает количество неподтвержденных сообщений, которые потребитель может получать одновременно. Если лимит достигнут, RabbitMQ остановит отправку новых сообщений до подтверждения (ack) хотя бы одного из уже полученных. Значение этого поля критично если нужно работать с очередями типа Stream, без этого параметра будет ошибка подключения.
// 
// Возвращаемое значение:
//   - 
//
Функция СоздатьКанал(Подключение, ПодтверждениеПубликацийОтСервера = Ложь, КоличествоПредзагруженныхНеПодтвержденныхСообщений = 0) Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	ОпцииКанала = ОпцииКанала(Подключение, ПодтверждениеПубликацийОтСервера, КоличествоПредзагруженныхНеПодтвержденныхСообщений);
	
	Лог(СтрШаблон("СоздатьКанал ОпцииКанала = %1", Сериализовать(ОпцииКанала)));
	
	Лог("ЭкземплярКомпоненты.СоздатьКанал Начало");
	
	Канал = ЭкземплярКомпоненты.СоздатьКанал(Сериализовать(ОпцииКанала));
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.СоздатьКанал Конец = %1", Канал));
	
	Возврат Десериализовать(Канал);
	
КонецФункции

Функция ОтменитьПолучателя(Получатель) Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Результат = ВалидацияСтруктурыПолучателя(Получатель);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Получатель.ТегПотребителя) Тогда
		Возврат СтруктураСОшибкой("Получатель отменяется по тегу, но тег не указан. Необходмо указывать тег при создании получателя, если требутся его отменять.");
	КонецЕсли;
	
	Ответ = ЭкземплярКомпоненты.ОтменитьПотребителя(Сериализовать(Получатель));
	
	Возврат Ответ;	
	//	Возврат Ответ = "consumer canceled";
	
КонецФункции

Функция ЗакрытьКанал(Канал) Экспорт
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Результат = ВалидацияСтруктурыКанал(Канал);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	Ответ = ЭкземплярКомпоненты.ЗакрытьКанал(Сериализовать(Канал));
	
	Возврат Ответ;	
	
	
КонецФункции

#КонецОбласти

#Область Получатели
Функция ВалидацияСтруктурыПолучателя(ОпцииПолучателя)
	Если НЕ 
		(
		ТипЗнч(ОпцииПолучателя) = Тип("Структура") 
		И ОпцииПолучателя.Свойство("Тип") 
		И ОпцииПолучателя.Тип = "Consumer" 
		) Тогда
		Возврат СтруктураСОшибкой("Не верный тип 'Получатель'");	
	КонецЕсли;	         
КонецФункции

// Функция - Опции получателя
//
// Параметры:
//  Канал			 - Сруктура с данными канала которую вернул метод СоздатьКанал
//  ИмяОчереди		 - Строка с именем очереди
//  ТэгПолучателя	 - Тег под которым получатель будет создан на сервере RMQ. Этот тег можно увидеть в админке в разделе comsumers
//  no_ack			 - Истина - автоматическое подтверждение получения сообщений, Ложь - требуется явное подтверждение получения каждого сообщения
//  exclusive		 - Истина - только один получатель может быть подключен к очереди, Ложь - разрешено подключение нескольких получателей
//  no_local		 - Истина - не получать сообщения, опубликованные через это же соединение, Ложь - получать все сообщения независимо от источника
//  nowait			 - Истина - не ждать подтверждения от сервера при создании получателя, Ложь - ждать подтверждение создания получателя от сервера
//  Таймаут			 - По истечении таймаута прекращается ожидание сообщений
//  Аргументы		 - Массив с аргументами для передачи доп. настроек для получателя. Каждый элемент это пара ключ, значение. Новый агрумент создается через функцию-конструктор НовыйАргумент(Ключ, Значение, Тип)
// 
// Возвращаемое значение: Структура опций получателя
//   - 
//
Функция ОпцииПолучателя(Канал, ИмяОчереди, ТэгПолучателя = "", no_ack = Ложь, exclusive = Ложь, no_local = Ложь, nowait = Ложь, Таймаут = 0, Аргументы = Неопределено)
	
	Результат = ВалидацияСтруктурыКанал(Канал);		
	
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Аргументы) Тогда
		Аргументы = Новый Массив;
	КонецЕсли;
	
	Возврат Новый Структура("Канал,ИмяОчереди,ТегПотребителя,no_ack,exclusive,no_local,nowait,Таймаут,Аргументы", Канал, ИмяОчереди, ТэгПолучателя, no_ack, exclusive, no_local, nowait, Таймаут, Аргументы);
КонецФункции

// Функция - Создать получателя для RabbitMQ
//
// Параметры:
//  Канал           - Число        - Идентификатор открытого канала RabbitMQ
//  ИмяОчереди      - Строка      - Имя очереди, из которой будут читаться сообщения
//  ТэгПолучателя   - Строка      - Любой строковый тег получателя
//  no_ack          - Булево      - Истина - автоматическое подтверждение получения сообщений
//                                  Ложь - требуется явное подтверждение получения каждого сообщения
//  exclusive       - Булево      - Истина - только один получатель может быть подключен к очереди
//                                  Ложь - разрешено подключение нескольких получателей
//  no_local        - Булево      - Истина - не получать сообщения, опубликованные через это же соединение
//                                  Ложь - получать все сообщения независимо от источника
//  nowait          - Булево      - Истина - не ждать подтверждения от сервера при создании получателя
//                                  Ложь - ждать подтверждение создания получателя от сервера
//  Таймаут			 - По истечении таймаута прекращается ожидание сообщений. Важно! Это таймаут ожидания, а не безусловное прерывание. т.е. таймаут отрботает только если в течении указанного времени не поступано ни сообщений из очереди ни команды ping. Если сообщения (или ping) поступают чаще чем таймаут, то он не будет работать, так как после каждой обработки сообщения таймайт начинает новый отсчет.
//
//  Аргументы		 - Массив с аргументами для передачи доп. настроек для получателя. Каждый элемент это пара ключ, значение. Новый агрумент создается через функцию-конструктор НовыйАргумент(Ключ, Значение, Тип)
// 
// Возвращаемое значение:
//   - Структура с данными созданного получателя
//
Функция СоздатьПолучателя(Канал, ИмяОчереди, ТэгПолучателя = "", no_ack = Ложь, exclusive = Ложь, no_local = Ложь, nowait = Ложь, Таймаут = 0, Аргументы = Неопределено) Экспорт
	
	Лог("СоздатьПолучателя");
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	ОпцииПолучателя = ОпцииПолучателя(Канал, ИмяОчереди, ТэгПолучателя, no_ack, exclusive, no_local, nowait, Таймаут, Аргументы);
	
	Лог(СтрШаблон("СоздатьПолучателя ОпцииПолучателя = %1", Сериализовать(ОпцииПолучателя)));
	
	Лог("ЭкземплярКомпоненты.ДобавитьПолучателяСообщений Начало");
	
	Получатель = ЭкземплярКомпоненты.ДобавитьПолучателяСообщений(Сериализовать(ОпцииПолучателя));
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.ДобавитьПолучателяСообщений Конец = %1", Получатель));
	
	Возврат Десериализовать(Получатель);
	
КонецФункции

Функция ПолучитьСписокПолучателейСообщений() Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	СписокJSON = ЭкземплярКомпоненты.ПолучитьСписокПолучателейСообщений();
	
	Возврат Десериализовать(СписокJSON);
	
КонецФункции


#КонецОбласти

#Область Очереди
// Функция - Опции очереди
//
// Параметры:
//  Канал																	 - Сруктура с данными канала которую вернул метод СоздатьКанал
//  ИмяОчереди																 - Строка с именем очереди
//  КлючМаршрутизации														 - Строка с ключем марштуризации
//  ТочкаОбмена																 - Строка с точной обмена
//  СохранятьОчередьИЕеСообщенияПослеПерезагрузкиСервера					 - Определяет, должна ли очередь выживать после перезагрузки брокера (сервера AMQP). Очереди, отмеченные как постоянные (durable: true), будут восстановлены после перезагрузки сервера вместе со всеми неподтвержденными сообщениями. Это увеличивает надежность системы за счет небольшой потери производительности.
//  ОчередьДоступнаТолькоОдномуПодключениюКотороеЕеСоздалоИНедоступнаДругим	 - Для создания эксклюзивных очередей. Указывает, что очередь будет использоваться только одним подключением и не будет доступна для других подключений. После закрытия подключения такая очередь будет удалена, что полезно для временных очередей, которые должны быть изолированы для одного пользователя.
//  АвтоудалениеПослеОтключенияПоследнегоПодписчика							 - Этот параметр контролирует автоматическое удаление очереди. Очередь будет автоматически удалена, когда последний подписчик (consumer) отписывается от неё. Это удобно для очередей, которые не должны существовать долго после окончания работы с ними.
//  Аргументы																 - Массив с аргументами для передачи доп. настроек для очереди. Каждый элемент это пара ключ, значение. Новый агрумент создается через функцию-конструктор НовыйАргумент(Ключ, Значение, Тип)
// 
// Возвращаемое значение:
//   - 
//
Функция ОпцииОчереди(
	Канал, 
	ИмяОчереди = "", 
	КлючМаршрутизации = "", 
	ТочкаОбмена = "", 
	СохранятьОчередьИЕеСообщенияПослеПерезагрузкиСервера = Ложь, 
	ОчередьДоступнаТолькоОдномуПодключениюКотороеЕеСоздалоИНедоступнаДругим = Ложь, 
	АвтоудалениеПослеОтключенияПоследнегоПодписчика = Ложь,
	Аргументы = Неопределено)
	
	ВалидацияСтруктурыКанал(Канал);		
	Результат = ВалидацияСтруктурыКанал(Канал);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Аргументы) Тогда
		Аргументы = Новый Массив;
	КонецЕсли;
	
	
	Возврат Новый Структура(
	"Канал, 
	|ИмяОчереди, 
	|ИмяТочкиОбмена, 
	|КлючМаршрутизации, 
	|УстойчивостьКПерезагрузкамСервера, 
	|ТолькоДляТекущегоСоединения, 
	|АвтоудалениеПослеОтключенияВсехПотребителей,
	|Аргументы", 
	Канал, 
	ИмяОчереди, 
	ТочкаОбмена, 
	КлючМаршрутизации, 
	СохранятьОчередьИЕеСообщенияПослеПерезагрузкиСервера, 
	ОчередьДоступнаТолькоОдномуПодключениюКотороеЕеСоздалоИНедоступнаДругим, 
	АвтоудалениеПослеОтключенияПоследнегоПодписчика,
	Аргументы
	);
	
КонецФункции

// Функция - Объявить очередь
//
// Параметры:
//  Канал																	 - Структура с данными канала, которые возвращает метод СоздатьКанал
//  ИмяОчереди																 - Строка с именем очереди
//  КлючМаршрутизации														 - Строка с ключем марштуризации 
//  ТочкаОбмена																 - Строка с точной обмена 
//  СохранятьОчередь														 - Определяет, должна ли очередь выживать после перезагрузки брокера (сервера AMQP). Очереди, отмеченные как постоянные (durable: true), будут восстановлены после перезагрузки сервера вместе со всеми неподтвержденными сообщениями. Это увеличивает надежность системы за счет небольшой потери производительности.
//  ОчередьДоступнаТолькоОдномуПодключениюКотороеЕеСоздалоИНедоступнаДругим	 - Для создания эксклюзивных очередей. Указывает, что очередь будет использоваться только одним подключением и не будет доступна для других подключений. После закрытия подключения такая очередь будет удалена, что полезно для временных очередей, которые должны быть изолированы для одного пользователя.
//  АвтоудалениеПослеОтключенияПоследнегоПодписчика							 - Этот параметр контролирует автоматическое удаление очереди. Очередь будет автоматически удалена, когда последний подписчик (consumer) отписывается от неё. Это удобно для очередей, которые не должны существовать долго после окончания работы с ними.
//  Аргументы																 - Массив с аргументами для передачи доп. настроек для очереди. Каждый элемент это пара ключ, значение. Новый агрумент создается через функцию-конструктор НовыйАргумент(Ключ, Значение, Тип)
// 
// Возвращаемое значение:
//   - 
//
Функция ОбъявитьОчередь(
	Канал, 
	ИмяОчереди = "", 
	КлючМаршрутизации = "", 
	ТочкаОбмена = "", 
	СохранятьОчередь = Ложь, 
	ОчередьДоступнаТолькоОдномуПодключениюКотороеЕеСоздалоИНедоступнаДругим = Ложь, 
	АвтоудалениеПослеОтключенияПоследнегоПодписчика = Ложь,
	Аргументы = Неопределено
	) Экспорт
	
	Лог("ОбъявитьОчередь");
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	ОпцииОчереди = ОпцииОчереди(
	Канал, 
	ИмяОчереди, 
	КлючМаршрутизации, 
	ТочкаОбмена, 
	СохранятьОчередь, 
	ОчередьДоступнаТолькоОдномуПодключениюКотороеЕеСоздалоИНедоступнаДругим, 
	АвтоудалениеПослеОтключенияПоследнегоПодписчика,
	Аргументы
	);                     
	
	Лог(СтрШаблон("ОбъявитьОчередь ОпцииОчереди = %1", ОпцииОчереди));
	
	Лог("ЭкземплярКомпоненты.ОбъявитьОчередь Начало");
	
	Очередь = ЭкземплярКомпоненты.ОбъявитьОчередь(Сериализовать(ОпцииОчереди));
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.ОбъявитьОчередь Конец Очередь = %1", Очередь));
	
	Возврат Десериализовать(Очередь);
	
КонецФункции
#КонецОбласти

#Область ПолучениеСообщения
Функция СледующееСообщение(Получатель) Экспорт
	
	Лог("СледующееСообщение");
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			ТекущееСообщение = Результат;
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Результат = ВалидацияСтруктурыПолучателя(Получатель);
	Если ЭтоОшибка(Результат) Тогда
		ТекущееСообщение = Результат;
		
		Лог(СтрШаблон("СледующееСообщение Ошибка = %1", Сериализовать(Результат)));
		
		Возврат Ложь;
	КонецЕсли;
	
	Попытка  
		ПолучатьЧастями = ЭтоLinux;
		
		Лог(СтрШаблон("ЭкземплярКомпоненты.СледующееСообщение Начало ПолучатьЧастями = %1", ПолучатьЧастями));
		
		Сообщение = ЭкземплярКомпоненты.СледующееСообщение(Сериализовать(Получатель), ПолучатьЧастями);
		
		Лог(СтрШаблон("ЭкземплярКомпоненты.СледующееСообщение Конец Сообщение.Длина = %1", СтрДлина(Сообщение)));
		
		Если ПолучатьЧастями Тогда
			Пока Истина Цикл
				
				Лог("ЭкземплярКомпоненты.ПолучитьЧастьСообщения Начало ПолучатьЧастями");
				
				ТекущееСообщение = ЭкземплярКомпоненты.ПолучитьЧастьСообщения();
				
				Лог(СтрШаблон("ЭкземплярКомпоненты.ПолучитьЧастьСообщения Конец Сообщение.Длина = %1", СтрДлина(ТекущееСообщение)));
				
				Если НЕ ЗначениеЗаполнено(ТекущееСообщение) Тогда
					Прервать;
				КонецЕсли;
				Сообщение = Сообщение + ТекущееСообщение;
			КонецЦикла;	
			
		КонецЕсли;
		
		ТекущееСообщение = Десериализовать(Сообщение);
	Исключение                      
		Возврат Ложь;
	КонецПопытки;
	
	ЭтоСообщение = ТипЗнч(ТекущееСообщение) = Тип("Структура") 
	И ТекущееСообщение.Свойство("Тип")
	И (
	ТекущееСообщение.Тип = Тип_Сообщение() // продолжать цикл ожидания если это сообщение из очереди ...
	ИЛИ ЭтоОтветНаПинг(ТекущееСообщение) // или ответ на ping (иначе это команда stop или другая ошибка (не сообщение) и нужно вернуть ложь, чтобы прервался цикл ожидания)
	);
	
	Лог(СтрШаблон("СледующееСообщение ЭтоСообщение = %1", ЭтоСообщение));
	
	Возврат ЭтоСообщение; 
	
КонецФункции

Функция ОдноСледующееСообщение(Канал, ИмяОчереди) Экспорт
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			ТекущееСообщение = Результат;
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Лог("ОдноСледующееСообщение");
	
	Результат = ВалидацияСтруктурыКанал(Канал);
	Если ЭтоОшибка(Результат) Тогда
		ТекущееСообщение = Результат;        
		
		Лог(СтрШаблон("ОдноСледующееСообщение ВалидацияСтруктурыКанал Ошибка = %1", Сериализовать(ТекущееСообщение)));
		
		Возврат Ложь;
	КонецЕсли;
	
	ОпцииПолученияОдногоСообщения = Новый Структура("Канал,ИмяОчереди", Канал, ИмяОчереди);            
	
	Лог(СтрШаблон("ОдноСледующееСообщение ОпцииПолученияОдногоСообщения = %1", Сериализовать(ОпцииПолученияОдногоСообщения)));
	
	Попытка
		ПолучатьЧастями = ЭтоLinux;
		
		Лог(СтрШаблон("ЭкземплярКомпоненты.ПолучитьОдноСообщение Начало ПолучатьЧастями = %1", ПолучатьЧастями));
		
		Сообщение = ЭкземплярКомпоненты.ПолучитьОдноСообщение(Сериализовать(ОпцииПолученияОдногоСообщения), ПолучатьЧастями);
		
		Лог(СтрШаблон("ЭкземплярКомпоненты.ПолучитьОдноСообщение Конец Сообщение.Длина = %1", СтрДлина(Сообщение)));
		
		Если ПолучатьЧастями Тогда
			Пока Истина Цикл
				
				Лог("ЭкземплярКомпоненты.ПолучитьЧастьСообщения Начало");
				
				ТекущееСообщение = ЭкземплярКомпоненты.ПолучитьЧастьСообщения();
				
				Лог(СтрШаблон("ЭкземплярКомпоненты.ПолучитьЧастьСообщения Конец Сообщение.Длина = %1", СтрДлина(ТекущееСообщение)));
				
				Если НЕ ЗначениеЗаполнено(ТекущееСообщение) Тогда
					Прервать;
				КонецЕсли;
				
				Сообщение = Сообщение + ТекущееСообщение;
			КонецЦикла;	
		КонецЕсли;	
		ТекущееСообщение = Десериализовать(Сообщение);
	Исключение                      
		Возврат Ложь;
	КонецПопытки;
	
	ЭтоСообщение = ТипЗнч(ТекущееСообщение) = Тип("Структура") 
	И ТекущееСообщение.Свойство("Тип")
	И ТекущееСообщение.Тип = Тип_Сообщение();
	
	Возврат ЭтоСообщение; 
	
КонецФункции

Функция ДанныеСообщения() Экспорт
	
	Лог(СтрШаблон("ДанныеСообщения ТекущееСообщение.Длина = %1", СтрДлина(Сериализовать(ТекущееСообщение))));
	
	Если ЭтоОшибка(ТекущееСообщение) Тогда
		Лог(СтрШаблон("ДанныеСообщения Ошибка = %1", Сериализовать(ТекущееСообщение)));	
	КонецЕсли;
	
	Возврат ТекущееСообщение;
	
КонецФункции

Функция СтруктураСОшибкой(ТекстОшибки)
	Возврат Новый Структура("Тип,Текст",Тип_Ошибка(), ТекстОшибки);	
КонецФункции

Функция СтруктураСообщения(ТегСообщения, ДанныеСообщения)
	Возврат Новый Структура("Тип, Тег, Данные",Тип_Сообщение(), ТегСообщения, ДанныеСообщения);	
КонецФункции

Функция ОпцииПодтвержденияСообщения(Канал, ТегСообщения)
	
	Результат = ВалидацияСтруктурыКанал(Канал);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	
	Возврат Новый Структура("Канал, Тег", Канал, ТегСообщения);	
КонецФункции

Функция ПодтвердитьСообщение(Канал, ТегСообщения) Экспорт
	
	Лог("ПодтвердитьСообщение");
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	ОпцииПодтвержденияСообщения = ОпцииПодтвержденияСообщения(Канал, ТегСообщения);
	
	Лог(СтрШаблон("ПодтвердитьСообщение ОпцииПодтвержденияСообщения = %1", Сериализовать(ОпцииПодтвержденияСообщения)));
	
	Результат = ЭкземплярКомпоненты.ПодтвердитьСообщение(Сериализовать(ОпцииПодтвержденияСообщения));
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.ПодтвердитьСообщение Результат = %1", Результат));
	
	Возврат Десериализовать(Результат);
КонецФункции

Функция ОпцииОтклоненияСообщения(Канал, ТегСообщения, ВернутьВИсходнуюОчередь)
	
	Результат = ВалидацияСтруктурыКанал(Канал);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	
	Возврат Новый Структура("Канал, Тег, ВернутьВИсходнуюОчередь", Канал, ТегСообщения, ВернутьВИсходнуюОчередь);	
КонецФункции

// Функция - Отклонить сообщение
//
// Параметры:
//  Канал					 - 	 - 
//  ТегСообщения			 - 	 - 
//  ВернутьВИсходнуюОчередь	 - если значение Истина, то сообщение вернется в исходную очередь. Если Ложь, то: если для исходной очереди не указан аргумент x-dead-letter-exchange то сообщение удалится, если указан, то переместится в очередь связанную с точкой обмена указанной в этом арументе. подробнее см. в справке в обработке ПримерОтклоненияСообщений в демо конфигурации
// 
// Возвращаемое значение:
//   - 
//
Функция ОтклонитьСообщение(Канал, ТегСообщения, ВернутьВИсходнуюОчередь) Экспорт
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	ОпцииОтклоненияСообщения = ОпцииОтклоненияСообщения(Канал, ТегСообщения, ВернутьВИсходнуюОчередь = Истина);
	
	Возврат Десериализовать( ЭкземплярКомпоненты.ОтклонитьСообщение(Сериализовать(ОпцииОтклоненияСообщения)));
КонецФункции

Функция СтруктураПолучателяДляПрерываняОжидания(ТегПотребителя) Экспорт
	Возврат Новый Структура("Тип,ПотребительТег","Consume", ТегПотребителя);
КонецФункции

Функция СтруктураПолучателяДляПинга(ТегПотребителя) Экспорт
	Возврат Новый Структура("Тип,ПотребительТег","Consume", ТегПотребителя);
КонецФункции

Функция ОстановитьОжиданиеСообщения(ПотребительДляПрерыванияОжидания) Экспорт
	
	Если ТипЗнч(ПотребительДляПрерыванияОжидания) <> Тип("Структура") Тогда
		Возврат СтруктураСОшибкой("Не верный тип данных, необходима структура");
	КонецЕсли;
	
	Если НЕ (ПотребительДляПрерыванияОжидания.Свойство("Тип") И ПотребительДляПрерыванияОжидания.Свойство("ПотребительТег")) Тогда
		Возврат СтруктураСОшибкой("Не верная структура, необходимы поля ""Тип,ПотребительТег""");
	КонецЕсли;
	
	Если ПотребительДляПрерыванияОжидания.Тип <> "Consume" Тогда
		Возврат СтруктураСОшибкой("Не верное значение свойства ""Тип""");
	КонецЕсли;
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Ответ = ЭкземплярКомпоненты.ОстановитьОжиданиеСообщения( Сериализовать(ПотребительДляПрерыванияОжидания) );
	
	Возврат Десериализовать(Ответ);
	
КонецФункции

Функция ПингПотребителя(ПотребительДляПинга) Экспорт
	
	Если ТипЗнч(ПотребительДляПинга) <> Тип("Структура") Тогда
		Возврат СтруктураСОшибкой("Не верный тип данных, необходима структура");
	КонецЕсли;
	
	Если НЕ (ПотребительДляПинга.Свойство("Тип") И ПотребительДляПинга.Свойство("ПотребительТег")) Тогда
		Возврат СтруктураСОшибкой("Не верная структура, необходимы поля ""Тип,ПотребительТег""");
	КонецЕсли;
	
	Если ПотребительДляПинга.Тип <> "Consume" Тогда
		Возврат СтруктураСОшибкой("Не верное значение свойства ""Тип""");
	КонецЕсли;
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Ответ = ЭкземплярКомпоненты.ПингПотребителя( Сериализовать(ПотребительДляПинга) );
	
	Возврат Десериализовать(Ответ);
	
КонецФункции

#КонецОбласти

#Область ПубликацияСообщения
// Функция - Опции публикации сообщения
//
// Параметры:
//  Данные						 -   -
//  Канал						 -   -
//  КлючМаршрутизации			 - 	 - 
//  ТочкаОбмена					 - 	 - 
//  СохранитьСообщениеНаДиске	 - 	Если указано, сообщение будет сохраняться на диске. Повышает надежность. Чтобы сообщение сохранилось после перезагрузки сервера, необходимо для канала указать СохранятьОчередь = Истина
// 
// Возвращаемое значение:
//   - 
//
Функция ОпцииПубликацииСообщения(Канал, КлючМаршрутизации = "", ТочкаОбмена = "", СохранитьСообщениеНаДиске = Ложь, СвойстваСообщения, Заголовки)
	Результат = ВалидацияСтруктурыКанал(Канал);		
	Если ЭтоОшибка(Результат) Тогда
		Возврат Результат;	
	КонецЕсли;
	
	
	Возврат Новый Структура("Канал, ИмяТочкиОбмена, КлючМаршрутизации, СохранитьСообщениеНаДиске, СвойстваСообщения, Заголовки", Канал, ТочкаОбмена, КлючМаршрутизации, СохранитьСообщениеНаДиске, СвойстваСообщения, Заголовки);
КонецФункции

Функция НовыеСвойстваСообщения(content_type = "",
	content_encoding = "",
	priority = "",
	correlation_id = "",
	reply_to = "",
	expiration = "",
	message_id = "",
	timestamp = "",
	type = "",
	user_id = "",
	app_id = "",
	cluster_id = "") Экспорт
	
	Возврат Новый Структура(
	"content_type,
	|content_encoding,
	|priority,
	|correlation_id,
	|reply_to,
	|expiration,
	|message_id,
	|timestamp,
	|type,
	|user_id,
	|app_id,
	|cluster_id",
	content_type,
	content_encoding,
	priority,
	correlation_id,
	reply_to,
	expiration,
	message_id,
	timestamp,
	type,
	user_id,
	app_id,
	cluster_id);	
	
КонецФункции

Функция ДобавитьЗаголовок(Ключ, Значение, Заголовки = Неопределено) Экспорт
	Если Заголовки = Неопределено Тогда
		Заголовки = Новый Массив;
	КонецЕсли;	
	
	Заголовки.Добавить(Новый Структура("Ключ,Значение", Ключ, Значение));
	
	Возврат Заголовки;
КонецФункции


// Функция - Опубликовать сообщение
//
// Параметры:
//  Канал						 - 	 - 
//  Данные						 - 	 - 
//  КлючМаршрутизации			 - 	 - 
//  ТочкаОбмена					 - 	 - 
//  СериализоватьДанные			 - 	 - 
//  СохранитьСообщениеНаДиске	 - Если указано, сообщение будет сохраняться на диске. Повышает надежность. Чтобы сообщение сохранилось после перезагрузки сервера, необходимо для очереди указать СохранятьОчередь = Истина (darable в web интерфесе)
// 
// Возвращаемое значение:
//   - 
//
Функция ОпубликоватьСообщение(Канал, Данные, КлючМаршрутизации = "", ТочкаОбмена = "", СериализоватьДанные = Истина, СохранитьСообщениеНаДиске = Ложь, СвойстваСообщения = Неопределено, Заголовки = Неопределено) Экспорт
	
	Лог("ОпубликоватьСообщение");
	
	Если ТипЗнч(Данные) = Тип("Структура") Тогда
		Данные = Сериализовать(Данные);
	КонецЕсли;
	
	Если ТипЗнч(Данные) <> Тип("Строка") Тогда
		Возврат СтруктураСОшибкой("Не поддерживаемый тип данных");	
	КонецЕсли;
	
	Если СвойстваСообщения = Неопределено Тогда
		СвойстваСообщения = НовыеСвойстваСообщения();
	КонецЕсли;
	
	Если Заголовки = Неопределено Тогда
		Заголовки = Новый Массив;
	КонецЕсли;
	
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Лог(СтрШаблон("ОпубликоватьСообщение ТочкаОбмена = %1 КлючМаршрутизации = %2 СохранитьСообщениеНаДиске = %3 СвойстваСообщения = %4 Заголовки = %5 Данные.Длина = %6", ТочкаОбмена, КлючМаршрутизации, СохранитьСообщениеНаДиске, Сериализовать(СвойстваСообщения), Сериализовать(Заголовки), СтрДлина(Данные) ));
	
	ОпцииПубликацииСообщения = ОпцииПубликацииСообщения(Канал, КлючМаршрутизации, ТочкаОбмена, СохранитьСообщениеНаДиске, СвойстваСообщения, Заголовки);
	
	Лог(СтрШаблон("ОпубликоватьСообщение ОпцииПубликацииСообщения = %1", Сериализовать(ОпцииПубликацииСообщения)));
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.ОпубликоватьСообщение Начало ЭтоLinux = %1", ЭтоLinux));
	
	Если ЭтоLinux Тогда
		ЭкземплярКомпоненты.start_sending_message();
		для каждого х из РазделитьСтрокуНаЧасти(Данные, 10000) цикл
			ЭкземплярКомпоненты.send_part_message(х);		
		КонецЦикла;
		Ответ = ЭкземплярКомпоненты.ОпубликоватьСообщение(Сериализовать(ОпцииПубликацииСообщения), "");
	Иначе	
		Ответ = ЭкземплярКомпоненты.ОпубликоватьСообщение(Сериализовать(ОпцииПубликацииСообщения), Данные);	
	КонецЕсли;
	
	Лог(СтрШаблон("ЭкземплярКомпоненты.ОпубликоватьСообщение Конец Ответ = %1", Ответ));
	
	Возврат Десериализовать(Ответ);
	
КонецФункции

Функция РазделитьСтрокуНаЧасти(Знач СтрокаВход, Знач ДлинаЧасти) Экспорт
	
	// Проверка входных параметров
	Если ПустаяСтрока(СтрокаВход) Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	Если ДлинаЧасти <= 0 Тогда
		ВызватьИсключение "Длина части должна быть положительным числом";
	КонецЕсли;
	
	// Инициализация результирующего массива
	МассивСтрок = Новый Массив;
	
	// Получаем длину входной строки
	ДлинаСтроки = СтрДлина(СтрокаВход);
	
	// Текущая позиция в строке
	ТекущаяПозиция = 1;
	
	// Разделяем строку на части
	Пока ТекущаяПозиция <= ДлинаСтроки Цикл
		
		// Определяем длину текущей части
		ТекущаяДлина = Мин(ДлинаЧасти, ДлинаСтроки - ТекущаяПозиция + 1);
		
		// Получаем подстроку и добавляем её в массив
		ЧастьСтроки = Сред(СтрокаВход, ТекущаяПозиция, ТекущаяДлина);
		МассивСтрок.Добавить(ЧастьСтроки);
		
		// Увеличиваем позицию
		ТекущаяПозиция = ТекущаяПозиция + ДлинаЧасти;
		
	КонецЦикла;
	
	Возврат МассивСтрок;
	
КонецФункции

#КонецОбласти

#Область ТочкиОбмена
Функция Exchange_direct() Экспорт
	Возврат "amq.direct";
КонецФункции

Функция Exchange_fanout() Экспорт
	Возврат "amq.fanout";
КонецФункции

Функция Exchange_headers() Экспорт
	Возврат "amq.headers";
КонецФункции

Функция Exchange_match() Экспорт
	Возврат "amq.match";
КонецФункции

Функция Exchange_rabbitmq_trace() Экспорт
	Возврат "amq.rabbitmq.trace";
КонецФункции

Функция Exchange_topic() Экспорт
	Возврат "amq.topic";
КонецФункции

#КонецОбласти

#Область ЗначениеПодтвержденияОтСервера
Функция ПодтверждениеСервера_НеЗапрашивалосьПодтверждение() Экспорт
	Возврат "not_requested";	
КонецФункции

Функция ПодтверждениеСервера_СерверПодтвердилПолучениеСообщения() Экспорт
	Возврат "is_ack";	
КонецФункции

Функция ПодтверждениеСервера_Сервер_НЕ_ПодтвердилПолучениеСообщения() Экспорт
	Возврат "is_nack";	
КонецФункции

#КонецОбласти

#Область Типы
Функция Тип_Подключение() Экспорт
	Возврат "Connect";		
КонецФункции 

Функция Тип_Канал() Экспорт
	Возврат "Channel";		
КонецФункции

Функция Тип_Очередь() Экспорт
	Возврат "Queue";		
КонецФункции

Функция Тип_Потребитель() Экспорт
	Возврат "Consumer";		
КонецФункции

Функция Тип_ИнформацияОСообщении() Экспорт
	Возврат "MessageInfo";		
КонецФункции

Функция Тип_ЧастьСообщения() Экспорт
	Возврат "MessagePart";		
КонецФункции

Функция Тип_СервисноеСообщение() Экспорт
	Возврат "ServiceMessage";		
КонецФункции

Функция Тип_Сообщение() Экспорт
	Возврат "Message";		
КонецФункции

Функция Тип_КонецСообщения() Экспорт
	Возврат "EndOfMessage";		
КонецФункции

Функция Тип_Ошибка() Экспорт
	Возврат "Error";		
КонецФункции 

Функция ЭтоОшибка(Структура)  Экспорт
	Возврат ТипЗнч(Структура) = Тип("Структура") И Структура.Свойство("Тип") И Структура.Тип = Тип_Ошибка();
КонецФункции

Функция ЭтоСервисноеСообщение(Структура)  Экспорт
	Возврат ТипЗнч(Структура) = Тип("Структура") И Структура.Свойство("Тип") И Структура.Тип = Тип_СервисноеСообщение();
КонецФункции

Функция ЭтоОтветНаПинг(Структура)  Экспорт
	Возврат ТипЗнч(Структура) = Тип("Структура") И Структура.Свойство("Тип") И Структура.Тип = Тип_СервисноеСообщение() И Структура.Текст = "pong";
КонецФункции


// Функция - Создается значение аргумента для передачи доп. аргументов при создани очередей и потребителей. В терминах библиотеки для rabbitMQ (lapin) это строка таблица FieldTable(). Применяется универсально для передачи аргументов при создании очередей, каналов и во многих прочих случаях где нужно через аргументы предать доп. настроки
//
// Параметры:
//  Ключ	 - Строка
//  Значение - Значение для ключа
//  Тип		 - На данный момент поддерживаются типы, строка,число,timestamp
// 
// Возвращаемое значение:
//   - 
//
Функция НовыйАргумент(Ключ, Значение, Тип = "") Экспорт
	
	Если НЕ ЗначениеЗаполнено(Тип) Тогда
		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			Тип = "строка";
		ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
			Тип = "число";	
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Ключ) <> Тип("Строка") Тогда
		Возврат СтруктураСОшибкой("Ошибка при вызове метода НовыйАргумент, Ключ может быть только строкой");		
	КонецЕсли;
	
	Если НЕ (НРег(Тип) = "число" ИЛИ НРег(Тип) = "строка" ИЛИ НРег(Тип) = "timestamp") Тогда
		Возврат СтруктураСОшибкой("Ошибка при вызове метода НовыйАргумент, не поддреживаетсый тип (значение параметра Тип)");	
	КонецЕсли;  
	
	Аргумент = Новый Структура("Ключ, ЗначениеТипаЧисло, ЗначениеТипаСтрока, ЗначениеТипаТаймштамп", Ключ, 0, "", 0);
	
	Если НРег(Тип) = "число" Тогда
		Аргумент.ЗначениеТипаЧисло = Значение;
	ИначеЕсли НРег(Тип) = "строка" Тогда
		Аргумент.ЗначениеТипаСтрока = Значение;
	ИначеЕсли НРег(Тип) = "timestamp" Тогда
		Аргумент.ЗначениеТипаТаймштамп = Значение;
	КонецЕсли;
	
	Возврат Аргумент;
	
КонецФункции

#КонецОбласти

#Область СервисныеСообщения
Функция СервисноеСообщение_УспешноеПодтверждениеПолученногоСообщения() Экспорт
	Возврат "basic_ack=ok";		
КонецФункции 
#КонецОбласти

#Область Общее
Функция ПроверитьВерсиюПлатформы()

	Лог("ПроверитьВерсиюПлатформы Начало");
	
	СисИнфо = Новый СистемнаяИнформация;
	СоставВерсий = СтрРазделить(СисИнфо.ВерсияПриложения,"."); 
	
	ЭтоWindows = СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64;
	
	ОснованяВерсия = Число(СоставВерсий[0]);
	МладшаяВерсия = Число(СоставВерсий[1]);
	Релиз = Число(СоставВерсий[2]);
	
	// Для windows поддерживается версия платформы начиная от 8.3.21 т.к. rust работат (!именно в win) только в изолированом режиме (в linux такой проблемы нет) 
	// В 8.3.21 появилась возможность выполнять внешние компоннеты в отдельном процессе (не в rphost)
	Если ЭтоWindows И НЕ (ОснованяВерсия = 8 И МладшаяВерсия = 3 И Релиз >= 21) Тогда
		СтруктураСОшибкой = СтруктураСОшибкой("В windows компонента может работать только в изолированном режиме, поэтому требуется версия платформы от 8.3.21 и выше. Или использовать linux (в linux нет ограничений на версию).");
		Лог("ПроверитьВерсиюПлатформы " + Сериализовать(СтруктураСОшибкой));
		Возврат СтруктураСОшибкой; 
	КонецЕсли;
	
	Лог("ПроверитьВерсиюПлатформы Ошибок нет");
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область Логирование
Процедура Лог(Текст, ДобавитьЕслиИстина = Истина)
	Если ЗаписьЛога = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ДобавитьЕслиИстина Тогда
		Возврат;
	КонецЕсли;
	ЗаписьЛога.ЗаписатьСтроку(СтрШаблон("[%1] %2", Формат(ТекущаяДатаСеанса(), "ДЛФ=DT"), Текст));
КонецПроцедуры

Процедура ЗаписьЛога(Путь) Экспорт
	Если ПустаяСтрока(Путь) Тогда
		ЗаписьЛога = Неопределено;
	КонецЕсли;
	ЗаписьЛога = Новый ЗаписьТекста;		
	ЗаписьЛога.Открыть(Путь, КодировкаТекста.UTF8,,Истина);
КонецПроцедуры
#КонецОбласти

Функция ПроверитьИмяИТокенДляКомпоненты(Имя = "", Токен = "") Экспорт
	Если ЭкземплярКомпоненты = Неопределено Тогда
		Результат = ПодключитьКомпоненту();
		Если ЭтоОшибка(Результат) Тогда
			Возврат Результат;	
		КонецЕсли;
	КонецЕсли;
	
	Лог(СтрШаблон("ПроверитьИмяИТокенДляКомпоненты Имя = %1 НачалоКонецТокена = %2...%3", Имя, Лев(Токен, 5), Прав(Токен, 5)));
	
	Если ЗначениеЗаполнено(Имя) И ЗначениеЗаполнено(Токен) Тогда
		ДанныеДляПроверки = Новый Структура("ИмяПользователя,Токен", Имя, Токен);
		РезультатПроверки = ЭкземплярКомпоненты.ПроверитьТокенЛицензииНаКомпоненту(Сериализовать(ДанныеДляПроверки));
		
		Лог(СтрШаблон("ПроверитьИмяИТокенДляКомпоненты РезультатПроверки = %1", РезультатПроверки));
		
		Возврат РезультатПроверки;
	КонецЕсли;
	
КонецФункции

Функция Сериализовать(Значение) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Значение);
	
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

Функция Десериализовать(Строка) Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Строка);
	Структура = ПрочитатьJSON(ЧтениеJSON);  
	ЧтениеJSON.Закрыть();               
	
	Возврат Структура;
КонецФункции 
